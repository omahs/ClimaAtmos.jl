using LinearAlgebra: √ó, norm, norm_sqr, dot

import ClimaAtmos.Parameters as CAP
using ClimaCore: Operators, Fields, Limiters

using ClimaCore.Geometry: ‚äó

import Thermodynamics as TD

using ClimaCore.Utilities: half

include("schur_complement_W.jl")
include("hyperdiffusion.jl")

# Note: FT must be defined before `include("staggered_nonhydrostatic_model.jl")`

# Functions on which the model depends:
# CAP.R_d(params)         # dry specific gas constant
# CAP.kappa_d(params)     # dry adiabatic exponent
# CAP.T_triple(params)    # triple point temperature of water
# CAP.MSLP(params)        # reference pressure
# CAP.grav(params)        # gravitational acceleration
# CAP.Omega(params)       # rotation rate (only used if space is spherical)
# CAP.cv_d(params)        # dry isochoric specific heat capacity
# The value of cv_d is implied by the values of R_d and kappa_d

# The model also depends on f_plane_coriolis_frequency(params)
# This is a constant Coriolis frequency that is only used if space is flat

# To add additional terms to the explicit part of the tendency, define new
# methods for `additional_cache` and `additional_tendency!`.

const div‚Çï = Operators.Divergence()
const wdiv‚Çï = Operators.WeakDivergence()
const grad‚Çï = Operators.Gradient()
const wgrad‚Çï = Operators.WeakGradient()
const curl‚Çï = Operators.Curl()
const wcurl‚Çï = Operators.WeakCurl()

const ·∂úinterp = Operators.InterpolateF2C()
const ·∂†interp = Operators.InterpolateC2F(
    bottom = Operators.Extrapolate(),
    top = Operators.Extrapolate(),
)
const ·∂údiv·µ• = Operators.DivergenceF2C(
    top = Operators.SetValue(Geometry.Contravariant3Vector(FT(0))),
    bottom = Operators.SetValue(Geometry.Contravariant3Vector(FT(0))),
)
const ·∂†grad·µ• = Operators.GradientC2F(
    bottom = Operators.SetGradient(Geometry.Covariant3Vector(FT(0))),
    top = Operators.SetGradient(Geometry.Covariant3Vector(FT(0))),
)
const ·∂†curl·µ• = Operators.CurlC2F(
    bottom = Operators.SetCurl(Geometry.Contravariant12Vector(FT(0), FT(0))),
    top = Operators.SetCurl(Geometry.Contravariant12Vector(FT(0), FT(0))),
)
const ·∂úFC = Operators.FluxCorrectionC2C(
    bottom = Operators.Extrapolate(),
    top = Operators.Extrapolate(),
)
const ·∂†upwind_product1 = Operators.UpwindBiasedProductC2F()
const ·∂†upwind_product3 = Operators.Upwind3rdOrderBiasedProductC2F(
    bottom = Operators.FirstOrderOneSided(),
    top = Operators.FirstOrderOneSided(),
)

const ·∂úinterp_stencil = Operators.Operator2Stencil(·∂úinterp)
const ·∂†interp_stencil = Operators.Operator2Stencil(·∂†interp)
const ·∂údiv·µ•_stencil = Operators.Operator2Stencil(·∂údiv·µ•)
const ·∂†grad·µ•_stencil = Operators.Operator2Stencil(·∂†grad·µ•)

const C123 = Geometry.Covariant123Vector

include("thermo_state.jl")

get_cache(Y, params, spaces, model_spec, numerics, simulation) = merge(
    default_cache(Y, params, spaces, numerics, simulation),
    additional_cache(Y, params, model_spec, simulation.dt),
)

function default_cache(Y, params, spaces, numerics, simulation)
    (; upwinding_mode, apply_limiters, move_K_term) = numerics
    ·∂úcoord = Fields.local_geometry_field(Y.c).coordinates
    ·∂†coord = Fields.local_geometry_field(Y.f).coordinates
    z_sfc = Fields.level(·∂†coord.z, half)
    if eltype(·∂úcoord) <: Geometry.LatLongZPoint
        Œ© = CAP.Omega(params)
        ·∂úf = @. 2 * Œ© * sind(·∂úcoord.lat)
        lat_sfc = Fields.level(·∂úcoord.lat, 1)
    else
        f = CAP.f_plane_coriolis_frequency(params)
        ·∂úf = map(_ -> f, ·∂úcoord)
        lat_sfc = map(_ -> FT(0), Fields.level(·∂úcoord, 1))
    end
    ·∂úf = @. Geometry.Contravariant3Vector(Geometry.WVector(·∂úf))
    T_sfc = @. 29 * exp(-lat_sfc^2 / (2 * 26^2)) + 271
    ts_type = thermo_state_type(Y.c, FT)
    ghost_buffer = (
        c = Spaces.create_ghost_buffer(Y.c),
        f = Spaces.create_ghost_buffer(Y.f),
        œá = Spaces.create_ghost_buffer(Y.c.œÅ), # for hyperdiffusion
        œáw = Spaces.create_ghost_buffer(Y.f.w.components.data.:1), # for hyperdiffusion
        œáu‚Çï = Spaces.create_ghost_buffer(Y.c.u‚Çï), # for hyperdiffusion
    )
    (:œÅq_tot in propertynames(Y.c)) && (
        ghost_buffer =
            (ghost_buffer..., ·∂úœáœÅq_tot = Spaces.create_ghost_buffer(Y.c.œÅ))
    )
    if apply_limiters
        tracers = filter(is_tracer_var, propertynames(Y.c))
        make_limiter = ·∂úùïã_name ->
            Limiters.QuasiMonotoneLimiter(getproperty(Y.c, ·∂úùïã_name), Y.c.œÅ)
        limiters = NamedTuple{tracers}(map(make_limiter, tracers))
    else
        limiters = nothing
    end
    return (;
        simulation,
        spaces,
        Y1‚Çú = apply_limiters ? similar(Y) : nothing,
        limiters,
        ·∂úuvw = similar(Y.c, Geometry.Covariant123Vector{FT}),
        ·∂úK = similar(Y.c, FT),
        ·∂úŒ¶ = CAP.grav(params) .* ·∂úcoord.z,
        ·∂úts = similar(Y.c, ts_type),
        ·∂úp = similar(Y.c, FT),
        ·∂úT = similar(Y.c, FT),
        ·∂ú3d_rain = similar(Y.c, FT),
        ·∂ú3d_snow = similar(Y.c, FT),
        ·∂úœâ¬≥ = similar(Y.c, Geometry.Contravariant3Vector{FT}),
        ·∂†œâ¬π¬≤ = similar(Y.f, Geometry.Contravariant12Vector{FT}),
        ·∂†u¬π¬≤ = similar(Y.f, Geometry.Contravariant12Vector{FT}),
        ·∂†u¬≥ = similar(Y.f, Geometry.Contravariant3Vector{FT}),
        ·∂úf,
        z_sfc,
        T_sfc,
        ‚àÇ·∂úK‚àÇ·∂†w_data = similar(
            Y.c,
            Operators.StencilCoefs{-half, half, NTuple{2, FT}},
        ),
        params,
        ·∂†upwind_product = upwinding_mode == :first_order ? ·∂†upwind_product1 :
                          upwinding_mode == :third_order ? ·∂†upwind_product3 :
                          nothing,
        move_K_term,
        ghost_buffer = ghost_buffer,
    )
end

# Used for automatically computing the Jacobian ‚àÇY‚Çú/‚àÇY. Currently requires
# allocation because the cache is stored separately from Y, which means that
# similar(Y, <:Dual) doesn't allocate an appropriate cache for computing Y‚Çú.
function implicit_cache_vars(
    Y::Fields.FieldVector{T},
    p,
) where {T <: AbstractFloat}
    (; ·∂úK, ·∂úts, ·∂úp) = p
    return (; ·∂úK, ·∂úts, ·∂úp)
end
function implicit_cache_vars(Y::Fields.FieldVector{T}, p) where {T <: Dual}
    ·∂úœÅ = Y.c.œÅ
    ·∂úK = similar(·∂úœÅ)
    ·∂úts = similar(·∂úœÅ, eltype(p.ts).name.wrapper{eltype(·∂úœÅ)})
    ·∂úp = similar(·∂úœÅ)
    return (; ·∂úK, ·∂úts, ·∂úp)
end

function implicit_tendency_special!(Y‚Çú, Y, p, t)
    (; apply_moisture_filter) = p
    apply_moisture_filter && affect_filter!(Y)
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úŒ¶, params, ·∂†upwind_product, move_K_term) = p
    thermo_params = CAP.thermodynamics_params(params)
    # Used for automatically computing the Jacobian ‚àÇY‚Çú/‚àÇY. Currently requires
    # allocation because the cache is stored separately from Y, which means that
    # similar(Y, <:Dual) doesn't allocate an appropriate cache for computing Y‚Çú.
    (; ·∂úK, ·∂úts, ·∂úp) = implicit_cache_vars(Y, p)

    ref_thermo_params = Ref(thermo_params)
    ref_zu‚Çï = Ref(zero(eltype(Y‚Çú.c.u‚Çï)))

    @nvtx "implicit tendency special" color = colorant"yellow" begin
        Fields.bycolumn(axes(Y.c)) do colidx

            if p.tendency_knobs.has_turbconv
                parent(Y‚Çú.c.turbconv[colidx]) .= FT(0)
                parent(Y‚Çú.f.turbconv[colidx]) .= FT(0)
            end

            @. ·∂úK[colidx] =
                norm_sqr(C123(·∂úu‚Çï[colidx]) + C123(·∂úinterp(·∂†w[colidx]))) / 2

            @. Y‚Çú.c.œÅ[colidx] = -(·∂údiv·µ•(·∂†interp(·∂úœÅ[colidx]) * ·∂†w[colidx]))

            thermo_state!(
                ·∂úts[colidx],
                Y.c[colidx],
                params,
                ·∂úinterp,
                ·∂úK[colidx],
                Y.f.w[colidx],
            )
            @. ·∂úp[colidx] = TD.air_pressure(ref_thermo_params, ·∂úts[colidx])
            if isnothing(·∂†upwind_product)
                @. Y‚Çú.c.œÅe_tot[colidx] = -(·∂údiv·µ•(
                    ·∂†interp(Y.c.œÅe_tot[colidx] + ·∂úp[colidx]) * ·∂†w[colidx],
                ))
            else
                @. Y‚Çú.c.œÅe_tot[colidx] = -(·∂údiv·µ•(
                    ·∂†interp(Y.c.œÅ[colidx]) * ·∂†upwind_product(
                        ·∂†w[colidx],
                        (Y.c.œÅe_tot[colidx] + ·∂úp[colidx]) / Y.c.œÅ[colidx],
                    ),
                ))
            end

            # TODO: Add flux correction to the Jacobian
            # @. Y‚Çú.c.œÅ += ·∂úFC(·∂†w, ·∂úœÅ)
            # if :œÅŒ∏ in propertynames(Y.c)
            #     @. Y‚Çú.c.œÅŒ∏ += ·∂úFC(·∂†w, ·∂úœÅŒ∏)
            # elseif :œÅe_tot in propertynames(Y.c)
            #     @. Y‚Çú.c.œÅe_tot += ·∂úFC(·∂†w, ·∂úœÅe)
            # elseif :œÅe_int in propertynames(Y.c)
            #     @. Y‚Çú.c.œÅe_int += ·∂úFC(·∂†w, ·∂úœÅe_int)
            # end

            Y‚Çú.c.u‚Çï[colidx] .= ref_zu‚Çï

            if move_K_term
                @. Y‚Çú.f.w[colidx] = -(
                    ·∂†grad·µ•(·∂úp[colidx]) / ·∂†interp(·∂úœÅ[colidx]) +
                    ·∂†grad·µ•(·∂úK[colidx] + ·∂úŒ¶[colidx])
                )
            else
                @. Y‚Çú.f.w[colidx] = -(
                    ·∂†grad·µ•(·∂úp[colidx]) / ·∂†interp(·∂úœÅ[colidx]) +
                    ·∂†grad·µ•(·∂úŒ¶[colidx])
                )
            end

            for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
                ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
                ·∂úùïã‚Çú = getproperty(Y‚Çú.c, ·∂úùïã_name)
                if isnothing(·∂†upwind_product)
                    @. ·∂úùïã‚Çú[colidx] = -(·∂údiv·µ•(·∂†interp(·∂úùïã[colidx]) * ·∂†w[colidx]))
                else
                    @. ·∂úùïã‚Çú[colidx] = -(·∂údiv·µ•(
                        ·∂†interp(Y.c.œÅ[colidx]) * ·∂†upwind_product(
                            ·∂†w[colidx],
                            ·∂úùïã[colidx] / Y.c.œÅ[colidx],
                        ),
                    ))
                end
            end
        end
    end
    return Y‚Çú
end

function implicit_tendency_generic!(Y‚Çú, Y, p, t)
    (; apply_moisture_filter) = p
    apply_moisture_filter && affect_filter!(Y)
    @nvtx "implicit tendency" color = colorant"yellow" begin
        ·∂úœÅ = Y.c.œÅ
        ·∂úu‚Çï = Y.c.u‚Çï
        ·∂†w = Y.f.w
        (; ·∂úK, ·∂úŒ¶, ·∂úts, ·∂úp, params, ·∂†upwind_product, move_K_term) = p
        thermo_params = CAP.thermodynamics_params(params)
        # Used for automatically computing the Jacobian ‚àÇY‚Çú/‚àÇY. Currently requires
        # allocation because the cache is stored separately from Y, which means that
        # similar(Y, <:Dual) doesn't allocate an appropriate cache for computing Y‚Çú.
        if eltype(Y) <: Dual
            ·∂úK = similar(·∂úœÅ)
            ·∂úts = similar(·∂úœÅ, eltype(·∂úts).name.wrapper{eltype(·∂úœÅ)})
            ·∂úp = similar(·∂úœÅ)
        end

        @. ·∂úK = norm_sqr(C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))) / 2

        @. Y‚Çú.c.œÅ = -(·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†w))

        thermo_state!(·∂úts, Y, params, ·∂úinterp, ·∂úK)
        @. ·∂úp = TD.air_pressure(thermo_params, ·∂úts)
        if :œÅŒ∏ in propertynames(Y.c)
            if isnothing(·∂†upwind_product)
                @. Y‚Çú.c.œÅŒ∏ = -(·∂údiv·µ•(·∂†interp(Y.c.œÅŒ∏) * ·∂†w))
            else
                @. Y‚Çú.c.œÅŒ∏ = -(·∂údiv·µ•(
                    ·∂†interp(Y.c.œÅ) * ·∂†upwind_product(·∂†w, Y.c.œÅŒ∏ / Y.c.œÅ),
                ))
            end
        elseif :œÅe_tot in propertynames(Y.c)
            if isnothing(·∂†upwind_product)
                @. Y‚Çú.c.œÅe_tot = -(·∂údiv·µ•(·∂†interp(Y.c.œÅe_tot + ·∂úp) * ·∂†w))
            else
                @. Y‚Çú.c.œÅe_tot = -(·∂údiv·µ•(
                    ·∂†interp(Y.c.œÅ) *
                    ·∂†upwind_product(·∂†w, (Y.c.œÅe_tot + ·∂úp) / Y.c.œÅ),
                ))
            end
        elseif :œÅe_int in propertynames(Y.c)
            if isnothing(·∂†upwind_product)
                @. Y‚Çú.c.œÅe_int = -(
                    ·∂údiv·µ•(·∂†interp(Y.c.œÅe_int + ·∂úp) * ·∂†w) - ·∂úinterp(
                        dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w)),
                    )
                )
                # or, equivalently,
                # Y‚Çú.c.œÅe_int = -(·∂údiv·µ•(·∂†interp(Y.c.œÅe_int) * ·∂†w) + ·∂úp * ·∂údiv·µ•(·∂†w))
            else
                @. Y‚Çú.c.œÅe_int = -(
                    ·∂údiv·µ•(
                        ·∂†interp(Y.c.œÅ) *
                        ·∂†upwind_product(·∂†w, (Y.c.œÅe_int + ·∂úp) / Y.c.œÅ),
                    ) - ·∂úinterp(
                        dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w)),
                    )
                )
            end
        end

        # TODO: Add flux correction to the Jacobian
        # @. Y‚Çú.c.œÅ += ·∂úFC(·∂†w, ·∂úœÅ)
        # if :œÅŒ∏ in propertynames(Y.c)
        #     @. Y‚Çú.c.œÅŒ∏ += ·∂úFC(·∂†w, ·∂úœÅŒ∏)
        # elseif :œÅe_tot in propertynames(Y.c)
        #     @. Y‚Çú.c.œÅe_tot += ·∂úFC(·∂†w, ·∂úœÅe)
        # elseif :œÅe_int in propertynames(Y.c)
        #     @. Y‚Çú.c.œÅe_int += ·∂úFC(·∂†w, ·∂úœÅe_int)
        # end

        Y‚Çú.c.u‚Çï .= Ref(zero(eltype(Y‚Çú.c.u‚Çï)))

        if move_K_term
            @. Y‚Çú.f.w = -(·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) + ·∂†grad·µ•(·∂úK + ·∂úŒ¶))
        else
            @. Y‚Çú.f.w = -(·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) + ·∂†grad·µ•(·∂úŒ¶))
        end

        for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
            ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
            ·∂úùïã‚Çú = getproperty(Y‚Çú.c, ·∂úùïã_name)
            if isnothing(·∂†upwind_product)
                @. ·∂úùïã‚Çú = -(·∂údiv·µ•(·∂†interp(·∂úùïã) * ·∂†w))
            else
                @. ·∂úùïã‚Çú =
                    -(·∂údiv·µ•(·∂†interp(Y.c.œÅ) * ·∂†upwind_product(·∂†w, ·∂úùïã / Y.c.œÅ)))
            end
        end
    end
    return Y‚Çú
end

function remaining_tendency!(Y‚Çú, Y, p, t)
    default_tends = p.default_remaining_tendencies
    @nvtx "remaining tendency" color = colorant"yellow" begin
        Y‚Çú .= zero(eltype(Y‚Çú))
        if !isnothing(default_tends)
            default_tends.horizontal_advection_tendency!(Y‚Çú, Y, p, t)
            default_tends.explicit_vertical_advection_tendency!(Y‚Çú, Y, p, t)
        end
        @nvtx "additional_tendency!" color = colorant"orange" begin
            additional_tendency!(Y‚Çú, Y, p, t)
        end
        @nvtx "dss_remaining_tendency" color = colorant"blue" begin
            Spaces.weighted_dss_start!(Y‚Çú.c, p.ghost_buffer.c)
            Spaces.weighted_dss_start!(Y‚Çú.f, p.ghost_buffer.f)
            Spaces.weighted_dss_internal!(Y‚Çú.c, p.ghost_buffer.c)
            Spaces.weighted_dss_internal!(Y‚Çú.f, p.ghost_buffer.f)
            Spaces.weighted_dss_ghost!(Y‚Çú.c, p.ghost_buffer.c)
            Spaces.weighted_dss_ghost!(Y‚Çú.f, p.ghost_buffer.f)
        end
    end
    return Y‚Çú
end

function remaining_tendency_increment!(Y2, Y1, p, t, dtŒ≥)
    (; Y1‚Çú, limiters) = p
    default_tends = p.default_remaining_tendencies
    @nvtx "remaining tendency increment" color = colorant"yellow" begin
        Y1‚Çú .= zero(eltype(Y1‚Çú))
        if !isnothing(default_tends)
            default_tends.horizontal_advection_tendency!(Y1‚Çú, Y1, p, t)
            if length(limiters) > 0
                @. Y2 += dtŒ≥ * Y1‚Çú
                for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y1.c))
                    ùïã_limiter = getproperty(limiters, ·∂úùïã_name)
                    ·∂úùïã1 = getproperty(Y1.c, ·∂úùïã_name)
                    ·∂úùïã2 = getproperty(Y2.c, ·∂úùïã_name)
                    Limiters.compute_bounds!(ùïã_limiter, ·∂úùïã1, Y1.c.œÅ)
                    Limiters.apply_limiter!(·∂úùïã2, Y2.c.œÅ, ùïã_limiter)
                end
                Y1‚Çú .= zero(eltype(Y1‚Çú))
            end
            default_tends.explicit_vertical_advection_tendency!(Y1‚Çú, Y1, p, t)
        end
        @nvtx "additional_tendency! increment" color = colorant"orange" begin
            additional_tendency!(Y1‚Çú, Y1, p, t)
            @. Y2 += dtŒ≥ * Y1‚Çú
        end
        @nvtx "dss_remaining_tendency increment" color = colorant"blue" begin
            Spaces.weighted_dss_start!(Y2.c, p.ghost_buffer.c)
            Spaces.weighted_dss_start!(Y2.f, p.ghost_buffer.f)
            Spaces.weighted_dss_internal!(Y2.c, p.ghost_buffer.c)
            Spaces.weighted_dss_internal!(Y2.f, p.ghost_buffer.f)
            Spaces.weighted_dss_ghost!(Y2.c, p.ghost_buffer.c)
            Spaces.weighted_dss_ghost!(Y2.f, p.ghost_buffer.f)
        end
    end
    return Y2
end

function horizontal_advection_tendency_special!(Y‚Çú, Y, p, t)
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úuvw, ·∂úK, ·∂úŒ¶, ·∂úts, ·∂úp, ·∂úœâ¬≥, ·∂†œâ¬π¬≤, ·∂†u¬π¬≤, ·∂†u¬≥, params) = p
    point_type = eltype(Fields.local_geometry_field(axes(Y.c)).coordinates)
    thermo_params = CAP.thermodynamics_params(params)

    # precomputed quantities
    @nvtx "precomputed quantities" color = colorant"orange" begin
        Fields.bycolumn(axes(Y.c)) do colidx
            @. ·∂úuvw[colidx] = C123(·∂úu‚Çï[colidx]) + C123(·∂úinterp(·∂†w[colidx]))
            @. ·∂úK[colidx] = norm_sqr(·∂úuvw[colidx]) / 2
            # Energy conservation
            thermo_state!(
                ·∂úts[colidx],
                Y.c[colidx],
                params,
                ·∂úinterp,
                ·∂úK[colidx],
                Y.f.w[colidx],
            )
            @. ·∂úp[colidx] = TD.air_pressure(thermo_params, ·∂úts[colidx])
            @. ·∂†u¬π¬≤[colidx] = Geometry.project(
                Geometry.Contravariant12Axis(),
                ·∂†interp(·∂úuvw[colidx]),
            )
            @. ·∂†u¬≥[colidx] = Geometry.project(
                Geometry.Contravariant3Axis(),
                C123(·∂†interp(·∂úu‚Çï[colidx])) + C123(·∂†w[colidx]),
            )
        end
    end

    ### horizontal
    @nvtx "horizontal" color = colorant"orange" begin
        # Mass conservation
        @. Y‚Çú.c.œÅ -= div‚Çï(·∂úœÅ * ·∂úuvw)

        # Energy conservation
        @. Y‚Çú.c.œÅe_tot -= div‚Çï((Y.c.œÅe_tot + ·∂úp) * ·∂úuvw)

        # Momentum conservation
        if point_type <: Geometry.Abstract3DPoint
            @. ·∂úœâ¬≥ = curl‚Çï(·∂úu‚Çï)
            @. ·∂†œâ¬π¬≤ = curl‚Çï(·∂†w)
        elseif point_type <: Geometry.Abstract2DPoint
            ·∂úœâ¬≥ .= Ref(zero(eltype(·∂úœâ¬≥)))
            @. ·∂†œâ¬π¬≤ = Geometry.Contravariant12Vector(curl‚Çï(·∂†w))
        end
        if point_type <: Geometry.Abstract3DPoint
            @. Y‚Çú.c.u‚Çï -= grad‚Çï(·∂úp) / ·∂úœÅ + grad‚Çï(·∂úK + ·∂úŒ¶)
        elseif point_type <: Geometry.Abstract2DPoint
            @. Y‚Çú.c.u‚Çï -=
                Geometry.Covariant12Vector(grad‚Çï(·∂úp) / ·∂úœÅ + grad‚Çï(·∂úK + ·∂úŒ¶))
        end

        # Tracer conservation
        for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
            ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
            ·∂úùïã‚Çú = getproperty(Y‚Çú.c, ·∂úùïã_name)
            @. ·∂úùïã‚Çú -= div‚Çï(·∂úùïã * ·∂úuvw)
        end
    end
end
function horizontal_advection_tendency_generic!(Y‚Çú, Y, p, t)
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úuvw, ·∂úK, ·∂úŒ¶, ·∂úts, ·∂úp, ·∂úœâ¬≥, ·∂†œâ¬π¬≤, ·∂†u¬π¬≤, ·∂†u¬≥, params) = p
    point_type = eltype(Fields.local_geometry_field(axes(Y.c)).coordinates)
    thermo_params = CAP.thermodynamics_params(params)

    @. ·∂úuvw = C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))
    @. ·∂úK = norm_sqr(·∂úuvw) / 2

    # Mass conservation
    @. Y‚Çú.c.œÅ -= div‚Çï(·∂úœÅ * ·∂úuvw)

    # Energy conservation
    thermo_state!(·∂úts, Y, params, ·∂úinterp, ·∂úK)
    @. ·∂úp = TD.air_pressure(thermo_params, ·∂úts)
    if :œÅŒ∏ in propertynames(Y.c)
        @. Y‚Çú.c.œÅŒ∏ -= div‚Çï(Y.c.œÅŒ∏ * ·∂úuvw)
    elseif :œÅe_tot in propertynames(Y.c)
        @. Y‚Çú.c.œÅe_tot -= div‚Çï((Y.c.œÅe_tot + ·∂úp) * ·∂úuvw)
    elseif :œÅe_int in propertynames(Y.c)
        if point_type <: Geometry.Abstract3DPoint
            @. Y‚Çú.c.œÅe_int -=
                div‚Çï((Y.c.œÅe_int + ·∂úp) * ·∂úuvw) -
                dot(grad‚Çï(·∂úp), Geometry.Contravariant12Vector(·∂úu‚Çï))
        else
            @. Y‚Çú.c.œÅe_int -=
                div‚Çï((Y.c.œÅe_int + ·∂úp) * ·∂úuvw) -
                dot(grad‚Çï(·∂úp), Geometry.Contravariant1Vector(·∂úu‚Çï))
        end
        # or, equivalently,
        # @. Y‚Çú.c.œÅe_int -= div‚Çï(Y.c.œÅe_int * ·∂úuvw) + ·∂úp * div‚Çï(·∂úuvw)
    end

    # Momentum conservation
    if point_type <: Geometry.Abstract3DPoint
        @. ·∂úœâ¬≥ = curl‚Çï(·∂úu‚Çï)
        @. ·∂†œâ¬π¬≤ = curl‚Çï(·∂†w)
    elseif point_type <: Geometry.Abstract2DPoint
        ·∂úœâ¬≥ .= Ref(zero(eltype(·∂úœâ¬≥)))
        @. ·∂†œâ¬π¬≤ = Geometry.Contravariant12Vector(curl‚Çï(·∂†w))
    end
    @. ·∂†u¬π¬≤ = Geometry.project(Geometry.Contravariant12Axis(), ·∂†interp(·∂úuvw))
    @. ·∂†u¬≥ = Geometry.project(
        Geometry.Contravariant3Axis(),
        C123(·∂†interp(·∂úu‚Çï)) + C123(·∂†w),
    )
    if point_type <: Geometry.Abstract3DPoint
        @. Y‚Çú.c.u‚Çï -= grad‚Çï(·∂úp) / ·∂úœÅ + grad‚Çï(·∂úK + ·∂úŒ¶)
    elseif point_type <: Geometry.Abstract2DPoint
        @. Y‚Çú.c.u‚Çï -=
            Geometry.Covariant12Vector(grad‚Çï(·∂úp) / ·∂úœÅ + grad‚Çï(·∂úK + ·∂úŒ¶))
    end

    # Tracer conservation
    for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
        ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
        ·∂úùïã‚Çú = getproperty(Y‚Çú.c, ·∂úùïã_name)
        @. ·∂úùïã‚Çú -= div‚Çï(·∂úùïã * ·∂úuvw)
    end
end

function explicit_vertical_advection_tendency_special!(Y‚Çú, Y, p, t)
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    (; ·∂úuvw, ·∂úK, ·∂úp, ·∂úœâ¬≥, ·∂†œâ¬π¬≤, ·∂†u¬π¬≤, ·∂†u¬≥, ·∂úf, move_K_term) = p

    @nvtx "vertical" color = colorant"orange" begin
        Fields.bycolumn(axes(Y.c)) do colidx
            # Mass conservation
            @. Y‚Çú.c.œÅ[colidx] -= ·∂údiv·µ•(·∂†interp(·∂úœÅ[colidx] * ·∂úu‚Çï[colidx]))

            # Energy conservation
            @. Y‚Çú.c.œÅe_tot[colidx] -=
                ·∂údiv·µ•(·∂†interp((Y.c.œÅe_tot[colidx] + ·∂úp[colidx]) * ·∂úu‚Çï[colidx]))

            # Momentum conservation
            @. ·∂†œâ¬π¬≤[colidx] += ·∂†curl·µ•(·∂úu‚Çï[colidx])
            @. Y‚Çú.c.u‚Çï[colidx] -=
                ·∂úinterp(·∂†œâ¬π¬≤[colidx] √ó ·∂†u¬≥[colidx]) +
                (·∂úf[colidx] + ·∂úœâ¬≥[colidx]) √ó
                (Geometry.project(Geometry.Contravariant12Axis(), ·∂úuvw[colidx]))
            if move_K_term
                @. Y‚Çú.f.w[colidx] -= ·∂†œâ¬π¬≤[colidx] √ó ·∂†u¬π¬≤[colidx]
            else
                @. Y‚Çú.f.w[colidx] -=
                    ·∂†œâ¬π¬≤[colidx] √ó ·∂†u¬π¬≤[colidx] + ·∂†grad·µ•(·∂úK[colidx])
            end

            # Tracer conservation
            for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
                ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
                ·∂úùïã‚Çú = getproperty(Y‚Çú.c, ·∂úùïã_name)
                @. ·∂úùïã‚Çú[colidx] -= ·∂údiv·µ•(·∂†interp(·∂úùïã[colidx] * ·∂úu‚Çï[colidx]))
            end
        end
    end
end
function explicit_vertical_advection_tendency_generic!(Y‚Çú, Y, p, t)
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    (; ·∂úuvw, ·∂úp, ·∂úœâ¬≥, ·∂†œâ¬π¬≤, ·∂†u¬π¬≤, ·∂†u¬≥, ·∂úf, move_K_term) = p

    # Mass conservation
    @. Y‚Çú.c.œÅ -= ·∂údiv·µ•(·∂†interp(·∂úœÅ * ·∂úu‚Çï))

    # Energy conservation
    if :œÅŒ∏ in propertynames(Y.c)
        @. Y‚Çú.c.œÅŒ∏ -= ·∂údiv·µ•(·∂†interp(Y.c.œÅŒ∏ * ·∂úu‚Çï))
    elseif :œÅe_tot in propertynames(Y.c)
        @. Y‚Çú.c.œÅe_tot -= ·∂údiv·µ•(·∂†interp((Y.c.œÅe_tot + ·∂úp) * ·∂úu‚Çï))
    elseif :œÅe_int in propertynames(Y.c)
        @. Y‚Çú.c.œÅe_int -= ·∂údiv·µ•(·∂†interp((Y.c.œÅe_int + ·∂úp) * ·∂úu‚Çï))
        # or, equivalently,
        # @. Y‚Çú.c.œÅe_int -=
        #     ·∂údiv·µ•(·∂†interp(Y.c.œÅe_int * ·∂úu‚Çï)) + ·∂úp * ·∂údiv·µ•(·∂†interp(·∂úu‚Çï))
    end

    # Momentum conservation
    @. ·∂†œâ¬π¬≤ += ·∂†curl·µ•(·∂úu‚Çï)
    @. Y‚Çú.c.u‚Çï -=
        ·∂úinterp(·∂†œâ¬π¬≤ √ó ·∂†u¬≥) +
        (·∂úf + ·∂úœâ¬≥) √ó (Geometry.project(Geometry.Contravariant12Axis(), ·∂úuvw))
    if move_K_term
        @. Y‚Çú.f.w -= ·∂†œâ¬π¬≤ √ó ·∂†u¬π¬≤
    else
        @. Y‚Çú.f.w -= ·∂†œâ¬π¬≤ √ó ·∂†u¬π¬≤ + ·∂†grad·µ•(·∂úK)
    end

    # Tracer conservation
    for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
        ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
        ·∂úùïã‚Çú = getproperty(Y‚Çú.c, ·∂úùïã_name)
        @. ·∂úùïã‚Çú -= ·∂údiv·µ•(·∂†interp(·∂úùïã * ·∂úu‚Çï))
    end
end

# Allow one() to be called on vectors.
Base.one(::T) where {T <: Geometry.AxisTensor} = one(T)
Base.one(::Type{T}) where {T‚Ä≤, A, S, T <: Geometry.AxisTensor{T‚Ä≤, 1, A, S}} =
    T(axes(T), S(one(T‚Ä≤)))

# :œÅe_tot in propertynames(Y.c) && flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :no_‚àÇ·∂úp‚àÇ·∂úK && flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
function Wfact_special!(W, Y, p, dtŒ≥, t)
    (; apply_moisture_filter) = p
    apply_moisture_filter && affect_filter!(Y)
    (; flags, dtŒ≥_ref) = W
    (; ‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ_named_tuple) = W
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úK, ·∂úŒ¶, ·∂úts, ·∂úp, ‚àÇ·∂úK‚àÇ·∂†w_data, params, ·∂†upwind_product, move_K_term) = p
    @nvtx "Wfact!" color = colorant"green" begin
        thermo_params = CAP.thermodynamics_params(params)

        R_d = FT(CAP.R_d(params))
        Œ∫_d = FT(CAP.kappa_d(params))
        cv_d = FT(CAP.cv_d(params))
        T_tri = FT(CAP.T_triple(params))
        MSLP = FT(CAP.MSLP(params))

        dtŒ≥_ref[] = dtŒ≥

        # If we let ·∂†w_data = ·∂†w.components.data.:1 and ·∂†w_unit = one.(·∂†w), then
        # ·∂†w == ·∂†w_data .* ·∂†w_unit. The Jacobian blocks involve ·∂†w_data, not ·∂†w.
        ·∂†w_data = ·∂†w.components.data.:1

        # If ‚àÇ(·∂úarg)/‚àÇ(·∂†w_data) = 0, then
        # ‚àÇ(·∂†upwind_product(·∂†w, ·∂úarg))/‚àÇ(·∂†w_data) =
        #     ·∂†upwind_product(·∂†w + Œµw, arg) / to_scalar(·∂†w + Œµw).
        # The Œµw is only necessary in case w = 0.
        Œµw = Ref(Geometry.Covariant3Vector(eps(FT)))
        to_scalar(vector) = vector.u‚ÇÉ

        to_scalar_coefs(vector_coefs) =
            map(vector_coef -> vector_coef.u‚ÇÉ, vector_coefs)

        ref_thermo_params = Ref(thermo_params)
        Fields.bycolumn(axes(Y.c)) do colidx
            @. ‚àÇ·∂úK‚àÇ·∂†w_data[colidx] =
                ·∂úinterp(·∂†w_data[colidx]) *
                norm_sqr(one(·∂úinterp(·∂†w[colidx]))) *
                ·∂úinterp_stencil(one(·∂†w_data[colidx]))
            @. ‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ[colidx] =
                -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅ[colidx]) * one(·∂†w[colidx])))

            # elseif :œÅe_tot in propertynames(Y.c)
            ·∂úœÅe = Y.c.œÅe_tot
            @. ·∂úK[colidx] =
                norm_sqr(C123(·∂úu‚Çï[colidx]) + C123(·∂úinterp(·∂†w[colidx]))) / 2
            thermo_state!(
                ·∂úts[colidx],
                Y.c[colidx],
                params,
                ·∂úinterp,
                ·∂úK[colidx],
                ·∂†w[colidx],
            )
            @. ·∂úp[colidx] = TD.air_pressure(ref_thermo_params, ·∂úts[colidx])

            if isnothing(·∂†upwind_product)
                #         elseif flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :no_‚àÇ·∂úp‚àÇ·∂úK
                #             # same as above, but we approximate ‚àÇ(·∂úp)/‚àÇ(·∂úK) = 0, so that
                #             # ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ has 3 diagonals instead of 5
                @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ[colidx] = -(·∂údiv·µ•_stencil(
                    ·∂†interp(·∂úœÅe[colidx] + ·∂úp[colidx]) * one(·∂†w[colidx]),
                ))
            else
                #         if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :no_‚àÇ·∂úp‚àÇ·∂úK
                @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ[colidx] = -(·∂údiv·µ•_stencil(
                    ·∂†interp(·∂úœÅ[colidx]) * ·∂†upwind_product(
                        ·∂†w[colidx] + Œµw,
                        (·∂úœÅe[colidx] + ·∂úp[colidx]) / ·∂úœÅ[colidx],
                    ) / to_scalar(·∂†w[colidx] + Œµw),
                ))
            end
            # elseif :œÅe_tot in propertynames(Y.c)
            # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅe) = ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
            # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe) = ·∂†grad·µ•_stencil(R_d / cv_d)
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº[colidx] = to_scalar_coefs(
                -1 / ·∂†interp(·∂úœÅ[colidx]) *
                ·∂†grad·µ•_stencil(R_d / cv_d * one(·∂úœÅe[colidx])),
            )


            # if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
            # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅ) =
            #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) +
            #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) * ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
            # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) =
            #     ·∂†grad·µ•_stencil(R_d * (-(·∂úK + ·∂úŒ¶) / cv_d + T_tri))
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) = ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2
            # ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ) = ·∂†interp_stencil(1)
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ[colidx] = to_scalar_coefs(
                -1 / ·∂†interp(·∂úœÅ[colidx]) * ·∂†grad·µ•_stencil(
                    R_d * (-(·∂úK[colidx] + ·∂úŒ¶[colidx]) / cv_d + T_tri),
                ) +
                ·∂†grad·µ•(·∂úp[colidx]) / abs2(·∂†interp(·∂úœÅ[colidx])) *
                ·∂†interp_stencil(one(·∂úœÅ[colidx])),
            )

            # elseif :œÅe_tot in propertynames(Y.c)
            if move_K_term
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ[colidx] = to_scalar_coefs(
                    compose(
                        -1 / ·∂†interp(·∂úœÅ[colidx]) *
                        ·∂†grad·µ•_stencil(-(·∂úœÅ[colidx] * R_d / cv_d)) +
                        -1 * ·∂†grad·µ•_stencil(one(·∂úK[colidx])),
                        ‚àÇ·∂úK‚àÇ·∂†w_data[colidx],
                    ),
                )
            else
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ[colidx] = to_scalar_coefs(
                    compose(
                        -1 / ·∂†interp(·∂úœÅ[colidx]) *
                        ·∂†grad·µ•_stencil(-(·∂úœÅ[colidx] * R_d / cv_d)),
                        ‚àÇ·∂úK‚àÇ·∂†w_data[colidx],
                    ),
                )
            end

            for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
                ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
                ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ = getproperty(‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ_named_tuple, ·∂úùïã_name)
                if isnothing(·∂†upwind_product)
                    # ·∂úùïã‚Çú = -·∂údiv·µ•(·∂†interp(·∂úùïã) * ·∂†w)
                    # ‚àÇ(·∂úùïã‚Çú)/‚àÇ(·∂†w_data) = -·∂údiv·µ•_stencil(·∂†interp(·∂úùïã) * ·∂†w_unit)
                    @. ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ[colidx] =
                        -(·∂údiv·µ•_stencil(·∂†interp(·∂úùïã[colidx]) * one(·∂†w[colidx])))
                else
                    # ·∂úùïã‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, ·∂úùïã / ·∂úœÅ))
                    # ‚àÇ(·∂úùïã‚Çú)/‚àÇ(·∂†w_data) =
                    #     -·∂údiv·µ•_stencil(
                    #         ·∂†interp(·∂úœÅ) * ‚àÇ(·∂†upwind_product(·∂†w, ·∂úùïã / ·∂úœÅ))/‚àÇ(·∂†w_data),
                    #     )
                    @. ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ[colidx] = -(·∂údiv·µ•_stencil(
                        ·∂†interp(·∂úœÅ[colidx]) * ·∂†upwind_product(
                            ·∂†w[colidx] + Œµw,
                            ·∂úùïã[colidx] / ·∂úœÅ[colidx],
                        ) / to_scalar(·∂†w[colidx] + Œµw),
                    ))
                end
            end
        end
    end
end


function Wfact_generic!(W, Y, p, dtŒ≥, t)
    (; apply_moisture_filter) = p
    apply_moisture_filter && affect_filter!(Y)
    (; flags, dtŒ≥_ref) = W
    (; ‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ_named_tuple) = W
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úK, ·∂úŒ¶, ·∂úts, ·∂úp, ‚àÇ·∂úK‚àÇ·∂†w_data, params, ·∂†upwind_product, move_K_term) = p
    @nvtx "Wfact!" color = colorant"green" begin
        thermo_params = CAP.thermodynamics_params(params)

        R_d = FT(CAP.R_d(params))
        Œ∫_d = FT(CAP.kappa_d(params))
        cv_d = FT(CAP.cv_d(params))
        T_tri = FT(CAP.T_triple(params))
        MSLP = FT(CAP.MSLP(params))

        dtŒ≥_ref[] = dtŒ≥

        # If we let ·∂†w_data = ·∂†w.components.data.:1 and ·∂†w_unit = one.(·∂†w), then
        # ·∂†w == ·∂†w_data .* ·∂†w_unit. The Jacobian blocks involve ·∂†w_data, not ·∂†w.
        ·∂†w_data = ·∂†w.components.data.:1

        # If ‚àÇ(·∂úarg)/‚àÇ(·∂†w_data) = 0, then
        # ‚àÇ(·∂†upwind_product(·∂†w, ·∂úarg))/‚àÇ(·∂†w_data) =
        #     ·∂†upwind_product(·∂†w + Œµw, arg) / to_scalar(·∂†w + Œµw).
        # The Œµw is only necessary in case w = 0.
        Œµw = Ref(Geometry.Covariant3Vector(eps(FT)))
        to_scalar(vector) = vector.u‚ÇÉ

        # ·∂úinterp(·∂†w) =
        #     ·∂úinterp(·∂†w)_data * ·∂úinterp(·∂†w)_unit =
        #     ·∂úinterp(·∂†w_data) * ·∂úinterp(·∂†w)_unit
        # norm_sqr(·∂úinterp(·∂†w)) =
        #     norm_sqr(·∂úinterp(·∂†w_data) * ·∂úinterp(·∂†w)_unit) =
        #     ·∂úinterp(·∂†w_data)^2 * norm_sqr(·∂úinterp(·∂†w)_unit)
        # ·∂úK =
        #     norm_sqr(C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))) / 2 =
        #     norm_sqr(·∂úu‚Çï) / 2 + norm_sqr(·∂úinterp(·∂†w)) / 2 =
        #     norm_sqr(·∂úu‚Çï) / 2 + ·∂úinterp(·∂†w_data)^2 * norm_sqr(·∂úinterp(·∂†w)_unit) / 2
        # ‚àÇ(·∂úK)/‚àÇ(·∂†w_data) =
        #     ‚àÇ(·∂úK)/‚àÇ(·∂úinterp(·∂†w_data)) * ‚àÇ(·∂úinterp(·∂†w_data))/‚àÇ(·∂†w_data) =
        #     ·∂úinterp(·∂†w_data) * norm_sqr(·∂úinterp(·∂†w)_unit) * ·∂úinterp_stencil(1)
        @. ‚àÇ·∂úK‚àÇ·∂†w_data =
            ·∂úinterp(·∂†w_data) *
            norm_sqr(one(·∂úinterp(·∂†w))) *
            ·∂úinterp_stencil(one(·∂†w_data))

        # ·∂úœÅ‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†w)
        # ‚àÇ(·∂úœÅ‚Çú)/‚àÇ(·∂†w_data) = -·∂údiv·µ•_stencil(·∂†interp(·∂úœÅ) * ·∂†w_unit)
        @. ‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅ) * one(·∂†w)))

        @. ·∂úK = norm_sqr(C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))) / 2
        thermo_state!(·∂úts, Y, params, ·∂úinterp, ·∂úK)
        @. ·∂úp = TD.air_pressure(thermo_params, ·∂úts)

        if :œÅŒ∏ in propertynames(Y.c)
            ·∂úœÅŒ∏ = Y.c.œÅŒ∏

            if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode != :exact
                error("‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode must be :exact when using œÅŒ∏")
            end

            if isnothing(·∂†upwind_product)
                # ·∂úœÅŒ∏‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅŒ∏) * ·∂†w)
                # ‚àÇ(·∂úœÅŒ∏‚Çú)/‚àÇ(·∂†w_data) = -·∂údiv·µ•_stencil(·∂†interp(·∂úœÅŒ∏) * ·∂†w_unit)
                @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅŒ∏) * one(·∂†w)))
            else
                # ·∂úœÅŒ∏‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, ·∂úœÅŒ∏ / ·∂úœÅ))
                # ‚àÇ(·∂úœÅŒ∏‚Çú)/‚àÇ(·∂†w_data) =
                #     -·∂údiv·µ•_stencil(
                #         ·∂†interp(·∂úœÅ) * ‚àÇ(·∂†upwind_product(·∂†w, ·∂úœÅŒ∏ / ·∂úœÅ))/‚àÇ(·∂†w_data),
                #     )
                @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(
                    ·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w + Œµw, ·∂úœÅŒ∏ / ·∂úœÅ) /
                    to_scalar(·∂†w + Œµw),
                ))
            end
        elseif :œÅe_tot in propertynames(Y.c)
            ·∂úœÅe = Y.c.œÅe_tot

            if isnothing(·∂†upwind_product)
                if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :exact
                    # ·∂úœÅe‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅe + ·∂úp) * ·∂†w)
                    # ‚àÇ(·∂úœÅe‚Çú)/‚àÇ(·∂†w_data) =
                    #     -·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe + ·∂úp) * ·∂†w_unit) -
                    #     ·∂údiv·µ•_stencil(·∂†w) * ‚àÇ(·∂†interp(·∂úœÅe + ·∂úp))/‚àÇ(·∂†w_data)
                    # ‚àÇ(·∂†interp(·∂úœÅe + ·∂úp))/‚àÇ(·∂†w_data) =
                    #     ‚àÇ(·∂†interp(·∂úœÅe + ·∂úp))/‚àÇ(·∂úp) * ‚àÇ(·∂úp)/‚àÇ(·∂†w_data)
                    # ‚àÇ(·∂†interp(·∂úœÅe + ·∂úp))/‚àÇ(·∂úp) = ·∂†interp_stencil(1)
                    # ‚àÇ(·∂úp)/‚àÇ(·∂†w_data) = ‚àÇ(·∂úp)/‚àÇ(·∂úK) * ‚àÇ(·∂úK)/‚àÇ(·∂†w_data)
                    # ‚àÇ(·∂úp)/‚àÇ(·∂úK) = -·∂úœÅ * R_d / cv_d
                    @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ =
                        -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe + ·∂úp) * one(·∂†w))) - compose(
                            ·∂údiv·µ•_stencil(·∂†w),
                            compose(
                                ·∂†interp_stencil(one(·∂úp)),
                                -(·∂úœÅ * R_d / cv_d) * ‚àÇ·∂úK‚àÇ·∂†w_data,
                            ),
                        )
                elseif flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :no_‚àÇ·∂úp‚àÇ·∂úK
                    # same as above, but we approximate ‚àÇ(·∂úp)/‚àÇ(·∂úK) = 0, so that
                    # ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ has 3 diagonals instead of 5
                    @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe + ·∂úp) * one(·∂†w)))
                else
                    error(
                        "‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode must be :exact or :no_‚àÇ·∂úp‚àÇ·∂úK when using œÅe_tot \
                        without upwinding",
                    )
                end
            else
                # TODO: Add Operator2Stencil for UpwindBiasedProductC2F to ClimaCore
                # to allow exact Jacobian calculation.
                if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :no_‚àÇ·∂úp‚àÇ·∂úK
                    # ·∂úœÅe‚Çú =
                    #     -·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, (·∂úœÅe + ·∂úp) / ·∂úœÅ))
                    # ‚àÇ(·∂úœÅe‚Çú)/‚àÇ(·∂†w_data) =
                    #     -·∂údiv·µ•_stencil(
                    #         ·∂†interp(·∂úœÅ) *
                    #         ‚àÇ(·∂†upwind_product(·∂†w, (·∂úœÅe + ·∂úp) / ·∂úœÅ))/‚àÇ(·∂†w_data),
                    #     )
                    @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(
                        ·∂†interp(·∂úœÅ) *
                        ·∂†upwind_product(·∂†w + Œµw, (·∂úœÅe + ·∂úp) / ·∂úœÅ) /
                        to_scalar(·∂†w + Œµw),
                    ))
                else
                    error(
                        "‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode must be :no_‚àÇ·∂úp‚àÇ·∂úK when using œÅe_tot with \
                      upwinding",
                    )
                end
            end
        elseif :œÅe_int in propertynames(Y.c)
            ·∂úœÅe_int = Y.c.œÅe_int

            if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode != :exact
                error("‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode must be :exact when using œÅe_int")
            end

            if isnothing(·∂†upwind_product)
                # ·∂úœÅe_int‚Çú =
                #     -(
                #         ·∂údiv·µ•(·∂†interp(·∂úœÅe_int + ·∂úp) * ·∂†w) -
                #         ·∂úinterp(dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w))
                #     )
                # ‚àÇ(·∂úœÅe_int‚Çú)/‚àÇ(·∂†w_data) =
                #     -(
                #         ·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe_int + ·∂úp) * ·∂†w_unit) -
                #         ·∂úinterp_stencil(dot(
                #             ·∂†grad·µ•(·∂úp),
                #             Geometry.Contravariant3Vector(·∂†w_unit),
                #         ),)
                #     )
                @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ = -(
                    ·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe_int + ·∂úp) * one(·∂†w)) -
                    ·∂úinterp_stencil(
                        dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(one(·∂†w))),
                    )
                )
            else
                # ·∂úœÅe_int‚Çú =
                #     -(
                #         ·∂údiv·µ•(
                #             ·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, (·∂úœÅe_int + ·∂úp) / ·∂úœÅ),
                #         ) -
                #         ·∂úinterp(dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w)))
                #     )
                # ‚àÇ(·∂úœÅe_int‚Çú)/‚àÇ(·∂†w_data) =
                #     -(
                #         ·∂údiv·µ•_stencil(
                #             ·∂†interp(·∂úœÅ) *
                #             ‚àÇ(·∂†upwind_product(·∂†w, (·∂úœÅe_int + ·∂úp) / ·∂úœÅ))/‚àÇ(·∂†w_data),
                #         ) -
                #         ·∂úinterp_stencil(dot(
                #             ·∂†grad·µ•(·∂úp),
                #             Geometry.Contravariant3Vector(·∂†w_unit),
                #         ),)
                #     )
                @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ = -(
                    ·∂údiv·µ•_stencil(
                        ·∂†interp(·∂úœÅ) *
                        ·∂†upwind_product(·∂†w + Œµw, (·∂úœÅe_int + ·∂úp) / ·∂úœÅ) /
                        to_scalar(·∂†w + Œµw),
                    ) - ·∂úinterp_stencil(
                        dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(one(·∂†w))),
                    )
                )
            end
        end

        # To convert ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úùîº) to ‚àÇ(·∂†w_data)‚Çú/‚àÇ(·∂úùîº) and ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†w_data) to
        # ‚àÇ(·∂†w_data)‚Çú/‚àÇ(·∂†w_data), we must extract the third component of each
        # vector-valued stencil coefficient.
        to_scalar_coefs(vector_coefs) =
            map(vector_coef -> vector_coef.u‚ÇÉ, vector_coefs)

        # TODO: If we end up using :gradŒ¶_shenanigans, optimize it to
        # `cached_stencil / ·∂†interp(·∂úœÅ)`.
        if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode != :exact &&
           flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode != :gradŒ¶_shenanigans
            error("‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode must be :exact or :gradŒ¶_shenanigans")
        end
        if :œÅŒ∏ in propertynames(Y.c)
            # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅŒ∏) = ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅŒ∏)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
            # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅŒ∏) =
            #     ·∂†grad·µ•_stencil(
            #         R_d / (1 - Œ∫_d) * (·∂úœÅŒ∏ * R_d / MSLP)^(Œ∫_d / (1 - Œ∫_d))
            #     )
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº = to_scalar_coefs(
                -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(
                    R_d / (1 - Œ∫_d) * (·∂úœÅŒ∏ * R_d / MSLP)^(Œ∫_d / (1 - Œ∫_d)),
                ),
            )

            if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
                # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
                # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅ) = ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) * ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ)
                # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) = ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2
                # ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ) = ·∂†interp_stencil(1)
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                    ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2 * ·∂†interp_stencil(one(·∂úœÅ)),
                )
            elseif flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :gradŒ¶_shenanigans
                # ·∂†w‚Çú = (
                #     -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ‚Ä≤) -
                #     ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ‚Ä≤) * ·∂†interp(·∂úœÅ)
                # ), where ·∂úœÅ‚Ä≤ = ·∂úœÅ but we approximate ‚àÇ(·∂úœÅ‚Ä≤)/‚àÇ(·∂úœÅ) = 0
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                    -(·∂†grad·µ•(·∂úŒ¶)) / ·∂†interp(·∂úœÅ) * ·∂†interp_stencil(one(·∂úœÅ)),
                )
            end
        elseif :œÅe_tot in propertynames(Y.c)
            # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅe) = ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
            # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe) = ·∂†grad·µ•_stencil(R_d / cv_d)
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº = to_scalar_coefs(
                -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(R_d / cv_d * one(·∂úœÅe)),
            )

            if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
                # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
                # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅ) =
                #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) +
                #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) * ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ)
                # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
                # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) =
                #     ·∂†grad·µ•_stencil(R_d * (-(·∂úK + ·∂úŒ¶) / cv_d + T_tri))
                # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) = ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2
                # ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ) = ·∂†interp_stencil(1)
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                    -1 / ·∂†interp(·∂úœÅ) *
                    ·∂†grad·µ•_stencil(R_d * (-(·∂úK + ·∂úŒ¶) / cv_d + T_tri)) +
                    ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2 * ·∂†interp_stencil(one(·∂úœÅ)),
                )
            elseif flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :gradŒ¶_shenanigans
                # ·∂†w‚Çú = (
                #     -·∂†grad·µ•(·∂úp‚Ä≤) / ·∂†interp(·∂úœÅ‚Ä≤) -
                #     ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ‚Ä≤) * ·∂†interp(·∂úœÅ)
                # ), where ·∂úœÅ‚Ä≤ = ·∂úœÅ but we approximate ‚àÇ·∂úœÅ‚Ä≤/‚àÇ·∂úœÅ = 0, and where
                # ·∂úp‚Ä≤ = ·∂úp but with ·∂úK = 0
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                    -1 / ·∂†interp(·∂úœÅ) *
                    ·∂†grad·µ•_stencil(R_d * (-(·∂úŒ¶) / cv_d + T_tri)) -
                    ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ) * ·∂†interp_stencil(one(·∂úœÅ)),
                )
            end
        elseif :œÅe_int in propertynames(Y.c)
            # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅe_int) = ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe_int)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
            # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe_int) = ·∂†grad·µ•_stencil(R_d / cv_d)
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº = to_scalar_coefs(
                -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(R_d / cv_d * one(·∂úœÅe_int)),
            )

            if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
                # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
                # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅ) =
                #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) +
                #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) * ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ)
                # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
                # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) = ·∂†grad·µ•_stencil(R_d * T_tri)
                # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) = ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2
                # ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ) = ·∂†interp_stencil(1)
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                    -1 / ·∂†interp(·∂úœÅ) *
                    ·∂†grad·µ•_stencil(R_d * T_tri * one(·∂úœÅe_int)) +
                    ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2 * ·∂†interp_stencil(one(·∂úœÅ)),
                )
            elseif flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :gradŒ¶_shenanigans
                # ·∂†w‚Çú = (
                #     -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ‚Ä≤) -
                #     ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ‚Ä≤) * ·∂†interp(·∂úœÅ)
                # ), where ·∂úp‚Ä≤ = ·∂úp but we approximate ‚àÇ·∂úœÅ‚Ä≤/‚àÇ·∂úœÅ = 0
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                    -1 / ·∂†interp(·∂úœÅ) *
                    ·∂†grad·µ•_stencil(R_d * T_tri * one(·∂úœÅe_int)) -
                    ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ) * ·∂†interp_stencil(one(·∂úœÅ)),
                )
            end
        end

        # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
        # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†w_data) =
        #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂†w_data‚Çú) +
        #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶)) * ‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶))/‚àÇ(·∂†w_data‚Çú) =
        #     (
        #         ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úK) +
        #         ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶)) * ‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶))/‚àÇ(·∂úK)
        #     ) * ‚àÇ(·∂úK)/‚àÇ(·∂†w_data‚Çú)
        # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
        # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úK) =
        #     ·∂úùîº_name == :œÅe_tot ? ·∂†grad·µ•_stencil(-·∂úœÅ * R_d / cv_d) : 0
        # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶)) = -1
        # ‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶))/‚àÇ(·∂úK) = ·∂†grad·µ•_stencil(1)
        # ‚àÇ(·∂úK)/‚àÇ(·∂†w_data) =
        #     ·∂úinterp(·∂†w_data) * norm_sqr(·∂úinterp(·∂†w)_unit) * ·∂úinterp_stencil(1)
        if :œÅŒ∏ in propertynames(Y.c) || :œÅe_int in propertynames(Y.c)
            if move_K_term
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ = to_scalar_coefs(
                    compose(-1 * ·∂†grad·µ•_stencil(one(·∂úK)), ‚àÇ·∂úK‚àÇ·∂†w_data),
                )
            else
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ .*= 0
            end
        elseif :œÅe_tot in propertynames(Y.c)
            if move_K_term
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ = to_scalar_coefs(
                    compose(
                        -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(-(·∂úœÅ * R_d / cv_d)) +
                        -1 * ·∂†grad·µ•_stencil(one(·∂úK)),
                        ‚àÇ·∂úK‚àÇ·∂†w_data,
                    ),
                )
            else
                @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ = to_scalar_coefs(
                    compose(
                        -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(-(·∂úœÅ * R_d / cv_d)),
                        ‚àÇ·∂úK‚àÇ·∂†w_data,
                    ),
                )
            end
        end

        for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
            ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
            ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ = getproperty(‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ_named_tuple, ·∂úùïã_name)
            if isnothing(·∂†upwind_product)
                # ·∂úùïã‚Çú = -·∂údiv·µ•(·∂†interp(·∂úùïã) * ·∂†w)
                # ‚àÇ(·∂úùïã‚Çú)/‚àÇ(·∂†w_data) = -·∂údiv·µ•_stencil(·∂†interp(·∂úùïã) * ·∂†w_unit)
                @. ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(·∂†interp(·∂úùïã) * one(·∂†w)))
            else
                # ·∂úùïã‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, ·∂úùïã / ·∂úœÅ))
                # ‚àÇ(·∂úùïã‚Çú)/‚àÇ(·∂†w_data) =
                #     -·∂údiv·µ•_stencil(
                #         ·∂†interp(·∂úœÅ) * ‚àÇ(·∂†upwind_product(·∂†w, ·∂úùïã / ·∂úœÅ))/‚àÇ(·∂†w_data),
                #     )
                @. ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(
                    ·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w + Œµw, ·∂úùïã / ·∂úœÅ) /
                    to_scalar(·∂†w + Œµw),
                ))
            end
        end

        # TODO: Figure out a way to test the Jacobian when the thermodynamic state
        # is PhaseEquil (i.e., when implicit_tendency! calls saturation adjustment).
        if W.test && !(eltype(·∂úts) <: TD.PhaseEquil)
            # Checking every column takes too long, so just check one.
            i, j, h = 1, 1, 1
            args = (implicit_tendency_generic!, Y, p, t, i, j, h)
            ·∂úùîº_name = filter(is_energy_var, propertynames(Y.c))[1]

            @assert matrix_column(‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ, axes(Y.f), i, j, h) ==
                    exact_column_jacobian_block(args..., (:c, :œÅ), (:f, :w))
            @assert matrix_column(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº, axes(Y.c), i, j, h) ‚âà
                    exact_column_jacobian_block(
                args...,
                (:f, :w),
                (:c, ·∂úùîº_name),
            )
            @assert matrix_column(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ, axes(Y.f), i, j, h) ‚âà
                    exact_column_jacobian_block(args..., (:f, :w), (:f, :w))
            for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
                ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ = getproperty(‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ_named_tuple, ·∂úùïã_name)
                ·∂úùïã_tuple = (:c, ·∂úùïã_name)
                @assert matrix_column(‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ, axes(Y.f), i, j, h) ‚âà
                        exact_column_jacobian_block(args..., ·∂úùïã_tuple, (:f, :w))
            end

            ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_approx = matrix_column(‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ, axes(Y.f), i, j, h)
            ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_exact =
                exact_column_jacobian_block(args..., (:c, ·∂úùîº_name), (:f, :w))
            if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :exact
                @assert ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_approx ‚âà ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_exact
            else
                err =
                    norm(‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_approx .- ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_exact) / norm(‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_exact)
                @assert err < 1e-6
                # Note: the highest value seen so far is ~3e-7 (only applies to œÅe_tot)
            end

            ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_approx = matrix_column(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ, axes(Y.c), i, j, h)
            ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_exact =
                exact_column_jacobian_block(args..., (:f, :w), (:c, :œÅ))
            if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
                @assert ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_approx ‚âà ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_exact
            else
                err =
                    norm(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_approx .- ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_exact) / norm(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_exact)
                @assert err < 0.03
                # Note: the highest value seen so far for œÅe_tot is ~0.01, and the
                # highest value seen so far for œÅŒ∏ is ~0.02
            end
        end
    end
end
